#pragma once
#include <random>
#include "bagrt"
// namespace
#define MATRIX_BEGIN        namespace mtx {
#define MATRIX_END          }


#define MATRIX              std::unique_ptr<double[]>
#define MATRIX_NULL         nullptr
#define MATRIX_BLANK        matrix();

MATRIX_BEGIN

std::default_random_engine  rand_e;

struct mtx_pos
{
    uint64_t ln = 0;
    uint64_t col = 0;
    friend std::ostream& operator<<(std::ostream &input, mtx_pos &val)
    {
        input << '(' << val.ln << ", " << val.col << ')';
        return input;
    }
};

struct mtx_info
{
    MATRIX mtx_val = nullptr;
    uint64_t ln_cnt = 0;
    uint64_t col_cnt = 0;
};

struct mtx_extm
{
    double val = 0;
    bagrt::net_list<mtx_pos> pos_list;
};

MATRIX_END

#define MATRIX_ELEM_MULT    0
#define MATRIX_ELEM_DIV     1
#define MATRIX_ELEM_POW     2

#define MATRIX_EQ_LU        true
#define MATRIX_EQ_JACOBI    false

#define MATRIX_POS          mtx::mtx_pos
#define MATRIX_INFO         mtx::mtx_info
#define MATRIX_EXTREME      mtx::mtx_extm

#include "matrix.hpp"

#define vect                mtx::matrix
#define feature             bagrt::net_queue<vect>
#define tensor              bagrt::net_queue<feature>

#define blank_vect          vect::blank_matrix()
#define blank_feature       feature::blank_queue()
#define blank_tensor        tensor::blank_queue()

#define blank_vect_seq      blank_feature
#define blank_ft_seq        blank_tensor

template<typename _Ty> using vect_t = bagrt::net_queue<bagrt::net_queue<_Ty>>;
template<typename _Ty> using set = bagrt::net_queue<_Ty>;